# philosophers

- thread, process의 사용방법 익히기
- 필수파트에서는 mutex lock, 보너스 파트에서는 semaphore를 사용해서 상호배제를 통한 thread와 process에서 접근하는 공유자원의 관리를 배울 수 있음
- 임계구역, 데이터 레이스, 데드락, 문맥전환, 동기화에 대한 내용을 배울 수 있음

## 학습 내용

- 임계구역 : 여러개의 thread 또는 process가 접근하는 영역 (공유자원)
- 데이터 레이스 : 임계구역에 여러 개의 thread 또는 process가 접근하거나 현상 (값 대입, 비교)
- 데드락 : 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태로 아래 총 4가지의 조건이 모두 만족할 때 발생함
    - 상호 배제 (Mutual exclusion) : 한 번에 하나의 프로세스만이 해당 자원을 사용
    - 점유 상태로 대기 (Hold and wait): 자원 하나를 붙잡은 상태에서 또 다른 자원을 기다리는 것
    - 선점 불가 (No preemption) : 다른 프로세스가 점유된 자원을 뺏어올 방법이 없음
    - 순환성 대기 (Circular wait) : 모든 프로세스가 다른 프로세스가 사용중인 있는 자원을 기다리는 상황에서, 마지막 프로세스가 첫 프로세스가 사용 중인 자원을 쓰기 위해 대기중인 상황
- 문맥전환 : 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 작업, 보관 된 이전 프로세스의 상태는 현재 프로세스에서 이전 프로세스로의 문맥전환이 일어날 때 다시 불러와짐
- 동기화 : 상기에서 설명한 데이터레이스를 방지하여 데이터의 일관성을 유지하는 것
- Mutex Lock : 임계구역에 접근하기 전에 lock을 걸고 접근해서 다른 프로세스나 쓰레드가 접근할 수 없게하고 작업이 끝난 후 unlock해서 데이터레이스를 방지하는 것 (임계구역 하나 당 하나의 Mutex Lock)
- Semaphore : 임계구역에 접근할 수 있는 최대 수를 정해놓고 임계구역에 접근하면 그 수를 감소시키고 0이되면 다른 프로세스나 쓰레드가 접근할 수 없게해서 데이터레이스를 방지하는 것

## Logic

- 필로소퍼를 최초 생성할 때 짝수, 홀수 순으로 생성함
- 짝수 필로소퍼가 생성하고 포크를 잡는 도중에 홀수 필로소퍼가 생성되어 간섭하면 짝수 필로와 홀수 필로가 점유 상태로 대기하게 되므로 200명 기준 짝수 필로 생성 후 usleep(2400) 정도의 시간을 주었음
- eating, sleep 동작에서 필로소퍼가 마지막으로 식사를 시작한 시점으로부터 현재 시간까지의 시간차를 계산하여 그 차이가 time_to_die에 가까워진다면 남은시간(remain_time)이 작아지므로 이를 usleep에 대입하여 연산 횟수를 높여서 처리 우선순위를 앞당김
- 옵저버 쓰레드의 연산 순위를 낮추기 위해 최초 시작할 때 홀수 필로까지 전부 생성된 후에 시작하도록 usleep을 주었음 (홀수 시작 전 usleep의 x2)
- 쓰레드 반복문에서도 usleep (12 * 10) 정도의 시간을 주어서 필로소퍼의 쓰레드가 우선적으로 처리되게끔 유도함
- check_time_over 쓰레드가 필로소퍼의 시간이 time_to_die만큼 지났는지 확인하는데 문맥교환으로 인해서 죽어야할 필로의 시간이 갱신되고나서 확인하는 것을 방지하기 위해 eating, sleep 과정에서도 time_to_die만큼의 시간이 지났는지 확인하는 로직을 추가함
- must eat의 구현은 필수파트에서는 배열을 활용한 flag로, 보너스 파트에서는 각 프로세스가 n_eat만큼 먹었으면 시간을 매번 갱신하는 로직에서의 세마포어 수를 wait하고 post하지 않게 되면 시간을 갱신하는 로직으로 들어가지 못하게 되어 1ms이상의 시간차이가 벌어지면 다 먹은 것으로 판단함
